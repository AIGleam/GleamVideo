#!/usr/bin/env python3

import soundfile as sf
import sounddevice as sd
from kokoro_onnx import Kokoro
import os
import sys
import itertools
import threading
import time
import signal
from ebooklib import epub
from bs4 import BeautifulSoup
import warnings

warnings.filterwarnings("ignore", category=UserWarning, module='ebooklib')
warnings.filterwarnings("ignore", category=FutureWarning, module='ebooklib')

# Global flag to stop the spinner and audio
stop_spinner = False
stop_audio = False

def spinning_wheel(message="Processing...", progress=None):
    """Display a spinning wheel with a message."""
    spinner = itertools.cycle(['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'])
    while not stop_spinner:
        if progress is not None:
            sys.stdout.write(f'\r{message} {progress}% {next(spinner)}')
        else:
            sys.stdout.write(f'\r{message} {next(spinner)}')
        sys.stdout.flush()
        time.sleep(0.1)
    # Clear the spinner line when done
    sys.stdout.write('\r' + ' ' * (len(message) + 10) + '\r')
    sys.stdout.flush()

def list_available_voices(kokoro):
    voices = list(kokoro.get_voices())
    print("Available voices:")
    for idx, voice in enumerate(voices):
        print(f"{idx + 1}. {voice}")
    return voices

def extract_text_from_epub(epub_file):
    book = epub.read_epub(epub_file)
    full_text = ""
    for item in book.get_items():
        # Check if the item is a document based on mime type (e.g., text/html, application/xhtml+xml)
        if item.get_type() == 9:  # 9 corresponds to DOCUMENT in ebooklib
            soup = BeautifulSoup(item.get_body_content(), "html.parser")  # Use get_body_content() here
            full_text += soup.get_text()
    return full_text

def chunk_text(text, chunk_size=1000):
    """Split text into chunks at sentence boundaries."""
    words = text.split()
    chunks = []
    current_chunk = []
    current_size = 0
    
    for word in words:
        current_chunk.append(word)
        current_size += len(word) + 1  # +1 for space
        
        if current_size >= chunk_size and word[-1] in '.!?':
            chunks.append(' '.join(current_chunk))
            current_chunk = []
            current_size = 0
    
    if current_chunk:
        chunks.append(' '.join(current_chunk))
    
    return chunks

def validate_language(lang, kokoro):
    """Validate if the language is supported."""
    try:
        supported_languages = set(kokoro.get_languages())  # Get supported languages from Kokoro
        if lang not in supported_languages:
            supported_langs = ', '.join(sorted(supported_languages))
            raise ValueError(f"Unsupported language: {lang}\nSupported languages are: {supported_langs}")
        return lang
    except Exception as e:
        print(f"Error getting supported languages: {e}")
        sys.exit(1)

def print_usage():
    print("""
Usage: kokoro-tts <input_text_file> [<output_audio_file>] [options]

Options:
    --stream        Stream audio instead of saving to file
    --speed <float> Set speech speed (default: 1.0)
    --lang <str>    Set language (default: en-us)
    --voice <str>   Set voice (default: interactive selection)

Note: 
    - Supported languages and voices depend on the model version.
    - Run with --help-languages to see available languages.
    - Run with --help-voices to see available voices.

Example:
    kokoro-tts input.txt output.wav --speed 1.2 --lang en-us --voice af_sarah
    kokoro-tts input.epub --stream
    """)

def print_supported_languages():
    """Print all supported languages from Kokoro."""
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        languages = sorted(kokoro.get_languages())
        print("\nSupported languages:")
        for lang in languages:
            print(f"    {lang}")
        print()
    except Exception as e:
        print(f"Error loading model to get supported languages: {e}")
        sys.exit(1)

def print_supported_voices():
    """Print all supported voices from Kokoro."""
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        voices = sorted(kokoro.get_voices())
        print("\nSupported voices:")
        for idx, voice in enumerate(voices):
            print(f"    {idx + 1}. {voice}")
        print()
    except Exception as e:
        print(f"Error loading model to get supported voices: {e}")
        sys.exit(1)

def validate_voice(voice, kokoro):
    """Validate if the voice is supported."""
    try:
        supported_voices = set(kokoro.get_voices())
        if voice not in supported_voices:
            supported_voices = ', '.join(sorted(supported_voices))
            raise ValueError(f"Unsupported voice: {voice}\nSupported voices are: {supported_voices}")
        return voice
    except Exception as e:
        print(f"Error getting supported voices: {e}")
        sys.exit(1)

def convert_text_to_audio(input_file, output_file=None, voice=None, speed=1.0, lang="en-us", stream=False):
    global stop_spinner
    # Load Kokoro model
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        # Validate language after loading model
        lang = validate_language(lang, kokoro)
        
        # Handle voice selection
        if voice:
            voice = validate_voice(voice, kokoro)
        else:
            # Interactive voice selection
            voices = list_available_voices(kokoro)
            try:
                voice_choice = int(input("Choose a voice by number: ")) - 1
                if voice_choice < 0 or voice_choice >= len(voices):
                    raise ValueError("Invalid choice")
                voice = voices[voice_choice]
            except (ValueError, IndexError):
                print("Invalid choice. Using default voice.")
                voice = "af_sarah"  # default voice
    except ValueError as e:
        print(f"Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error loading Kokoro model: {e}")
        sys.exit(1)
    
    # Read the input file (handle .txt or .epub)
    if input_file.endswith('.epub'):
        text = extract_text_from_epub(input_file)
    else:
        with open(input_file, 'r', encoding='utf-8') as file:
            text = file.read()

    if stream or not output_file:
        import asyncio
        asyncio.run(stream_audio(kokoro, text, voice, speed, lang))
    else:
        # Split into chunks for better progress reporting
        chunks = chunk_text(text)
        all_samples = []
        sample_rate = None
        
        for i, chunk in enumerate(chunks, 1):
            if stop_audio:
                break
            # Start spinner with chunk progress
            stop_spinner = False
            spinner_thread = threading.Thread(
                target=spinning_wheel,
                args=(f"Processing chunk {i}/{len(chunks)}",)
            )
            spinner_thread.start()
            
            # Process chunk
            chunk_samples, sample_rate = kokoro.create(
                chunk, voice=voice, speed=speed, lang=lang
            )
            all_samples.extend(chunk_samples)
            
            # Stop spinner for this chunk
            stop_spinner = True
            spinner_thread.join()
        
        if all_samples:
            # Show final saving message
            stop_spinner = False
            spinner_thread = threading.Thread(
                target=spinning_wheel,
                args=("Saving audio file...",)
            )
            spinner_thread.start()
            
            # Save the complete audio file
            sf.write(output_file, all_samples, sample_rate)
            
            stop_spinner = True
            spinner_thread.join()
            print(f"\nCreated {output_file}")

async def stream_audio(kokoro, text, voice, speed, lang):
    global stop_spinner, stop_audio
    stop_spinner = False
    stop_audio = False
    
    print("Starting audio stream...")
    chunks = chunk_text(text)
    
    for i, chunk in enumerate(chunks, 1):
        if stop_audio:
            break
        # Update progress percentage
        progress = int((i / len(chunks)) * 100)
        spinner_thread = threading.Thread(
            target=spinning_wheel, 
            args=(f"Streaming chunk {i}/{len(chunks)}",)
        )
        spinner_thread.start()
        
        async for samples, sample_rate in kokoro.create_stream(
            chunk, voice=voice, speed=speed, lang=lang
        ):
            if stop_audio:
                break
            sd.play(samples, sample_rate)
            sd.wait()
        
        stop_spinner = True
        spinner_thread.join()
        stop_spinner = False
    
    print("\nStreaming completed.")

def handle_ctrl_c(signum, frame):
    global stop_spinner, stop_audio
    print("\nCtrl+C detected, stopping...")
    stop_spinner = True
    stop_audio = True
    sys.exit(0)

# Register the signal handler for SIGINT (Ctrl+C)
signal.signal(signal.SIGINT, handle_ctrl_c)

if __name__ == "__main__":
    # Handle help commands first
    if len(sys.argv) == 2:
        if sys.argv[1] in ['-h', '--help']:
            print_usage()
            sys.exit(0)
        elif sys.argv[1] == '--help-languages':
            print_supported_languages()
            sys.exit(0)
        elif sys.argv[1] == '--help-voices':
            print_supported_voices()
            sys.exit(0)
    
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 and not sys.argv[2].startswith('--') else None
    stream = '--stream' in sys.argv
    speed = 1.0  # default speed
    lang = "en-us"  # default language
    voice = None  # default to interactive selection
    
    # Parse optional arguments
    for i, arg in enumerate(sys.argv):
        if arg == '--speed' and i + 1 < len(sys.argv):
            try:
                speed = float(sys.argv[i + 1])
            except ValueError:
                print("Error: Speed must be a number")
                sys.exit(1)
        elif arg == '--lang' and i + 1 < len(sys.argv):
            lang = sys.argv[i + 1]
        elif arg == '--voice' and i + 1 < len(sys.argv):
            voice = sys.argv[i + 1]
    
    # Ensure the input file exists
    if not os.path.isfile(input_file):
        print(f"Error: The file {input_file} does not exist.")
        sys.exit(1)
    
    # Ensure the output file has a proper extension if not streaming
    if output_file and not output_file.endswith(('.wav', '.mp3')):
        print("Error: Output file must have .wav or .mp3 extension.")
        sys.exit(1)
    
    # Convert text to audio or stream
    convert_text_to_audio(input_file, output_file, voice=voice, stream=stream, speed=speed, lang=lang)

