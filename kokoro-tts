#!/usr/bin/env python3

import soundfile as sf
import sounddevice as sd
from kokoro_onnx import Kokoro
import os
import sys
import itertools
import threading
import time
import signal
from ebooklib import epub
from bs4 import BeautifulSoup
import warnings
import concurrent.futures
from queue import Queue
from threading import Event

warnings.filterwarnings("ignore", category=UserWarning, module='ebooklib')
warnings.filterwarnings("ignore", category=FutureWarning, module='ebooklib')

# Global flag to stop the spinner and audio
stop_spinner = False
stop_audio = False

def spinning_wheel(message="Processing...", progress=None):
    """Display a spinning wheel with a message."""
    spinner = itertools.cycle(['⠋', '⠙', '⠹', '⠸', '⠼', '⠴', '⠦', '⠧', '⠇', '⠏'])
    while not stop_spinner:
        spin = next(spinner)
        if progress is not None:
            sys.stdout.write(f"\r{message} {progress} {spin}")
        else:
            sys.stdout.write(f"\r{message} {spin}")
        sys.stdout.flush()
        time.sleep(0.1)
    # Clear the spinner line when done
    sys.stdout.write('\r' + ' ' * (len(message) + 50) + '\r')
    sys.stdout.flush()

def list_available_voices(kokoro):
    voices = list(kokoro.get_voices())
    print("Available voices:")
    for idx, voice in enumerate(voices):
        print(f"{idx + 1}. {voice}")
    return voices

def extract_text_from_epub(epub_file):
    book = epub.read_epub(epub_file)
    full_text = ""
    for item in book.get_items():
        # Check if the item is a document based on mime type (e.g., text/html, application/xhtml+xml)
        if item.get_type() == 9:  # 9 corresponds to DOCUMENT in ebooklib
            soup = BeautifulSoup(item.get_body_content(), "html.parser")  # Use get_body_content() here
            full_text += soup.get_text()
    return full_text

def chunk_text(text, chunk_size=2000):
    """Split text into chunks at sentence boundaries."""
    sentences = text.replace('\n', ' ').split('.')
    chunks = []
    current_chunk = []
    current_size = 0
    
    for sentence in sentences:
        if not sentence.strip():
            continue  # Skip empty sentences
        
        sentence = sentence.strip() + '.'
        sentence_size = len(sentence)
        
        # Start new chunk if current one would be too large
        if current_size + sentence_size > chunk_size and current_chunk:
            chunks.append(' '.join(current_chunk))
            current_chunk = []
            current_size = 0
        
        current_chunk.append(sentence)
        current_size += sentence_size
    
    if current_chunk:
        chunks.append(' '.join(current_chunk))
    
    return chunks

def validate_language(lang, kokoro):
    """Validate if the language is supported."""
    try:
        supported_languages = set(kokoro.get_languages())  # Get supported languages from Kokoro
        if lang not in supported_languages:
            supported_langs = ', '.join(sorted(supported_languages))
            raise ValueError(f"Unsupported language: {lang}\nSupported languages are: {supported_langs}")
        return lang
    except Exception as e:
        print(f"Error getting supported languages: {e}")
        sys.exit(1)

def print_usage():
    print("""
Usage: kokoro-tts <input_text_file> [<output_audio_file>] [options]

Options:
    --stream            Stream audio instead of saving to file
    --speed <float>     Set speech speed (default: 1.0)
    --lang <str>        Set language (default: en-us)
    --voice <str>       Set voice (default: interactive selection)
    --split-output <dir> Save each chunk as separate file in directory
    --format <str>      Audio format: wav or mp3 (default: wav)
    --workers <int>     Number of parallel workers (default: 2)

Note: Higher worker counts use more memory. Reduce workers if you encounter memory issues.

Example:
    kokoro-tts input.txt output.wav --speed 1.2 --lang en-us --voice af_sarah
    kokoro-tts input.epub --split-output ./chunks/ --format mp3 --workers 2
    """)

def print_supported_languages():
    """Print all supported languages from Kokoro."""
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        languages = sorted(kokoro.get_languages())
        print("\nSupported languages:")
        for lang in languages:
            print(f"    {lang}")
        print()
    except Exception as e:
        print(f"Error loading model to get supported languages: {e}")
        sys.exit(1)

def print_supported_voices():
    """Print all supported voices from Kokoro."""
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        voices = sorted(kokoro.get_voices())
        print("\nSupported voices:")
        for idx, voice in enumerate(voices):
            print(f"    {idx + 1}. {voice}")
        print()
    except Exception as e:
        print(f"Error loading model to get supported voices: {e}")
        sys.exit(1)

def validate_voice(voice, kokoro):
    """Validate if the voice is supported."""
    try:
        supported_voices = set(kokoro.get_voices())
        if voice not in supported_voices:
            supported_voices = ', '.join(sorted(supported_voices))
            raise ValueError(f"Unsupported voice: {voice}\nSupported voices are: {supported_voices}")
        return voice
    except Exception as e:
        print(f"Error getting supported voices: {e}")
        sys.exit(1)

def extract_chapters_from_epub(epub_file):
    """Extract chapters from epub file with their titles."""
    book = epub.read_epub(epub_file)
    chapters = []
    
    for item in book.get_items():
        if item.get_type() == 9:  # DOCUMENT type
            soup = BeautifulSoup(item.get_body_content(), "html.parser")
            
            # Try to find chapter title from common heading patterns
            title = None
            for heading in soup.find_all(['h1', 'h2', 'h3']):
                if heading.text.strip():
                    title = heading.text.strip()
                    break
            
            # If no heading found, try to use item title or generate one
            if not title:
                title = getattr(item, 'title', None) or f"Chapter {len(chapters) + 1}"
            
            # Get chapter content
            content = soup.get_text().strip()
            if content:  # Only add if there's actual content
                chapters.append({
                    'title': title,
                    'content': content
                })
    
    return chapters

def process_chunk(args):
    """Process a single chunk of text."""
    chunk, voice, speed, lang = args
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        samples, sample_rate = kokoro.create(chunk, voice=voice, speed=speed, lang=lang)
        del kokoro
        import gc
        gc.collect()  # Force garbage collection
        return samples, sample_rate
    except Exception as e:
        print(f"\nError processing chunk: {e}")
        return None, None

def convert_text_to_audio(input_file, output_file=None, voice=None, speed=1.0, lang="en-us", 
                         stream=False, split_output=None, format="wav", max_workers=2):
    global stop_spinner
    # Load Kokoro model
    try:
        kokoro = Kokoro("kokoro-v0_19.onnx", "voices.json")
        # Validate language after loading model
        lang = validate_language(lang, kokoro)
        
        # Handle voice selection
        if voice:
            voice = validate_voice(voice, kokoro)
        else:
            # Interactive voice selection
            voices = list_available_voices(kokoro)
            try:
                voice_choice = int(input("Choose a voice by number: ")) - 1
                if voice_choice < 0 or voice_choice >= len(voices):
                    raise ValueError("Invalid choice")
                voice = voices[voice_choice]
            except (ValueError, IndexError):
                print("Invalid choice. Using default voice.")
                voice = "af_sarah"  # default voice
    except ValueError as e:
        print(f"Error: {e}")
        sys.exit(1)
    except Exception as e:
        print(f"Error loading Kokoro model: {e}")
        sys.exit(1)
    
    # Read the input file (handle .txt or .epub)
    if input_file.endswith('.epub'):
        chapters = extract_chapters_from_epub(input_file)
        if not chapters:
            print("No chapters found in EPUB file.")
            sys.exit(1)
    else:
        with open(input_file, 'r', encoding='utf-8') as file:
            text = file.read()
        # Treat single text file as one chapter
        chapters = [{'title': 'Chapter 1', 'content': text}]

    if stream:
        import asyncio
        # Stream each chapter
        for chapter in chapters:
            print(f"\nStreaming: {chapter['title']}")
            asyncio.run(stream_audio(kokoro, chapter['content'], voice, speed, lang))
    else:
        if split_output:
            os.makedirs(split_output, exist_ok=True)
            
            for chapter_num, chapter in enumerate(chapters, 1):
                print(f"\nProcessing: {chapter['title']}")
                chapter_dir = os.path.join(split_output, f"chapter_{chapter_num:03d}")
                os.makedirs(chapter_dir, exist_ok=True)
                
                with open(os.path.join(chapter_dir, "info.txt"), "w", encoding="utf-8") as f:
                    f.write(f"Title: {chapter['title']}\n")
                
                # Process chunks in smaller batches to manage memory
                chunks = chunk_text(chapter['content'], chunk_size=1000)  # Further reduced chunk size
                total_chunks = len(chunks)
                processed_chunks = 0
                batch_size = 2  # Reduced batch size
                
                for batch_start in range(0, len(chunks), batch_size):
                    if stop_audio:  # Check for interruption
                        break
                    
                    batch_end = min(batch_start + batch_size, len(chunks))
                    batch = chunks[batch_start:batch_end]
                    chunk_args = [(chunk, voice, speed, lang) for chunk in batch]
                    
                    # Create progress bar for current batch
                    filled = "■" * processed_chunks
                    current = "□" * len(batch)
                    remaining = "□" * (total_chunks - processed_chunks - len(batch))
                    progress_bar = f"[{filled}{current}{remaining}] ({processed_chunks}/{total_chunks})"
                    
                    stop_spinner = False
                    spinner_thread = threading.Thread(
                        target=spinning_wheel,
                        args=(f"Processing {chapter['title']}", progress_bar)
                    )
                    spinner_thread.start()
                    
                    try:
                        with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers) as executor:
                            futures = {executor.submit(process_chunk, args): i 
                                     for i, args in enumerate(chunk_args, batch_start + 1)}
                            
                            for future in concurrent.futures.as_completed(futures):
                                if stop_audio:  # Check for interruption
                                    break
                                chunk_num = futures[future]
                                try:
                                    samples, sample_rate = future.result()
                                    if samples is not None:
                                        chunk_file = os.path.join(chapter_dir, f"chunk_{chunk_num:03d}.{format}")
                                        sf.write(chunk_file, samples, sample_rate)
                                        processed_chunks += 1
                                except Exception as e:
                                    print(f"\nError processing chunk {chunk_num}: {e}")
                    
                    except Exception as e:
                        print(f"\nError processing batch: {e}")
                    finally:
                        stop_spinner = True
                        spinner_thread.join()
                    
                    if stop_audio:  # Check for interruption
                        break
                
                print(f"\nCompleted {chapter['title']}: {processed_chunks}/{total_chunks} chunks processed")
                
                if stop_audio:  # Check for interruption
                    break
            
            print(f"\nCreated audio files for {len(chapters)} chapters in {split_output}/")
        else:
            # Combine all chapters into one file
            all_samples = []
            sample_rate = None
            
            for chapter_num, chapter in enumerate(chapters, 1):
                print(f"\nProcessing: {chapter['title']}")
                chunks = chunk_text(chapter['content'], chunk_size=2000)
                processed_chunks = 0
                
                # Process chunks sequentially in smaller batches
                batch_size = max_workers  # Process chunks in batches
                for batch_start in range(0, len(chunks), batch_size):
                    batch_end = min(batch_start + batch_size, len(chunks))
                    batch = chunks[batch_start:batch_end]
                    
                    # Prepare batch arguments
                    chunk_args = [
                        (chunk, voice, speed, lang)
                        for chunk in batch
                    ]
                    
                    stop_spinner = False
                    spinner_thread = threading.Thread(
                        target=spinning_wheel,
                        args=(f"Processing batch {batch_start//batch_size + 1}/{(len(chunks)-1)//batch_size + 1}",)
                    )
                    spinner_thread.start()
                    
                    # Process batch
                    with concurrent.futures.ProcessPoolExecutor(max_workers=max_workers) as executor:
                        futures = {executor.submit(process_chunk, args): i 
                                 for i, args in enumerate(chunk_args, batch_start + 1)}
                        
                        for future in concurrent.futures.as_completed(futures):
                            chunk_num = futures[future]
                            try:
                                samples, sr = future.result()
                                if samples is not None:
                                    if sample_rate is None:
                                        sample_rate = sr
                                    all_samples.extend(samples)
                                    processed_chunks += 1
                                    print(f"\rProgress: {processed_chunks}/{len(chunks)} chunks", end="")
                            except Exception as e:
                                print(f"\nError processing chunk {chunk_num}: {e}")
                    
                    stop_spinner = True
                    spinner_thread.join()
                
                print(f"\nCompleted {chapter['title']}: {processed_chunks}/{len(chunks)} chunks processed")
            
            if all_samples:
                print("\nSaving complete audio file...")
                if not output_file:
                    output_file = f"{os.path.splitext(input_file)[0]}.{format}"
                sf.write(output_file, all_samples, sample_rate)
                print(f"Created {output_file}")

async def stream_audio(kokoro, text, voice, speed, lang):
    global stop_spinner, stop_audio
    stop_spinner = False
    stop_audio = False
    
    print("Starting audio stream...")
    chunks = chunk_text(text)
    
    for i, chunk in enumerate(chunks, 1):
        if stop_audio:
            break
        # Update progress percentage
        progress = int((i / len(chunks)) * 100)
        spinner_thread = threading.Thread(
            target=spinning_wheel, 
            args=(f"Streaming chunk {i}/{len(chunks)}",)
        )
        spinner_thread.start()
        
        async for samples, sample_rate in kokoro.create_stream(
            chunk, voice=voice, speed=speed, lang=lang
        ):
            if stop_audio:
                break
            sd.play(samples, sample_rate)
            sd.wait()
        
        stop_spinner = True
        spinner_thread.join()
        stop_spinner = False
    
    print("\nStreaming completed.")

def handle_ctrl_c(signum, frame):
    global stop_spinner, stop_audio
    print("\nCtrl+C detected, stopping...")
    stop_spinner = True
    stop_audio = True
    sys.exit(0)

# Register the signal handler for SIGINT (Ctrl+C)
signal.signal(signal.SIGINT, handle_ctrl_c)

if __name__ == "__main__":
    # Handle help commands first
    if len(sys.argv) == 2:
        if sys.argv[1] in ['-h', '--help']:
            print_usage()
            sys.exit(0)
        elif sys.argv[1] == '--help-languages':
            print_supported_languages()
            sys.exit(0)
        elif sys.argv[1] == '--help-voices':
            print_supported_voices()
            sys.exit(0)
    
    if len(sys.argv) < 2:
        print_usage()
        sys.exit(1)
    
    input_file = sys.argv[1]
    output_file = sys.argv[2] if len(sys.argv) > 2 and not sys.argv[2].startswith('--') else None
    stream = '--stream' in sys.argv
    speed = 1.0  # default speed
    lang = "en-us"  # default language
    voice = None  # default to interactive selection
    split_output = None
    format = "wav"  # default format
    max_workers = 2  # default reduced to 2
    
    # Parse optional arguments
    for i, arg in enumerate(sys.argv):
        if arg == '--speed' and i + 1 < len(sys.argv):
            try:
                speed = float(sys.argv[i + 1])
            except ValueError:
                print("Error: Speed must be a number")
                sys.exit(1)
        elif arg == '--lang' and i + 1 < len(sys.argv):
            lang = sys.argv[i + 1]
        elif arg == '--voice' and i + 1 < len(sys.argv):
            voice = sys.argv[i + 1]
        elif arg == '--split-output' and i + 1 < len(sys.argv):
            split_output = sys.argv[i + 1]
        elif arg == '--format' and i + 1 < len(sys.argv):
            format = sys.argv[i + 1].lower()
            if format not in ['wav', 'mp3']:
                print("Error: Format must be either 'wav' or 'mp3'")
                sys.exit(1)
        elif arg == '--workers' and i + 1 < len(sys.argv):
            try:
                max_workers = int(sys.argv[i + 1])
                if max_workers < 1:
                    raise ValueError
                if max_workers > 4:
                    print("Warning: High worker count may cause memory issues")
            except ValueError:
                print("Error: Workers must be a positive integer")
                sys.exit(1)
    
    # Ensure the input file exists
    if not os.path.isfile(input_file):
        print(f"Error: The file {input_file} does not exist.")
        sys.exit(1)
    
    # Ensure the output file has a proper extension if specified
    if output_file and not output_file.endswith(('.' + format)):
        print(f"Error: Output file must have .{format} extension.")
        sys.exit(1)
    
    # Convert text to audio or stream
    convert_text_to_audio(input_file, output_file, voice=voice, stream=stream, 
                         speed=speed, lang=lang, split_output=split_output, format=format, max_workers=max_workers)

